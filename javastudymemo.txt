不论是float 还是double都是浮点数，而计算机是二进制的，浮点数会失去一定的精确度。
注:根本原因是:十进制值通常没有完全相同的二进制表示形式;十进制数的二进制表示形式可能不精确。只能无限接近于那个值
但是，在项目中，我们不可能让这种情况出现，特别是金融项目，因为涉及金额的计算都必须十分精确
1、简介
Java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，在商业计算中要用java.math.BigDecimal。BigDecimal所创建的是对象，我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。
2、构造器描述 
BigDecimal(int)       创建一个具有参数所指定整数值的对象。 
BigDecimal(double) 创建一个具有参数所指定双精度值的对象。 //不推荐使用
BigDecimal(long)    创建一个具有参数所指定长整数值的对象。 
BigDecimal(String) 创建一个具有参数所指定以字符串表示的数值的对象。//推荐使用
3、方法描述 
add(BigDecimal)        BigDecimal对象中的值相加，然后返回这个对象。 
subtract(BigDecimal) BigDecimal对象中的值相减，然后返回这个对象。 
multiply(BigDecimal)  BigDecimal对象中的值相乘，然后返回这个对象。 
divide(BigDecimal)     BigDecimal对象中的值相除，然后返回这个对象。 
toString()                将BigDecimal对象的数值转换成字符串。 
doubleValue()          将BigDecimal对象中的值以双精度数返回。 
floatValue()             将BigDecimal对象中的值以单精度数返回。 
longValue()             将BigDecimal对象中的值以长整数返回。 
intValue()               将BigDecimal对象中的值以整数返回。
JDK的描述：
1、参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于0.1（虽然表面上等于该值）。
2、另一方面，String 构造方法是完全可预知的：写入 newBigDecimal("0.1") 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法
当double必须用作BigDecimal的源时，请使用Double.toString(double)转成String，然后使用String构造方法，或使用BigDecimal的静态方法valueOf，
这边特别提一下，如果进行除法运算的时候，结果不能整除，有余数，这个时候会报java.lang.ArithmeticException: ，这边我们要避免这个错误产生，在进行除法运算的时候，针对可能出现的小数产生的计算，必须要多传两个参数divide(BigDecimal，保留小数点后几位小数，舍入模式)
舍入模式
ROUND_CEILING    //向正无穷方向舍入
ROUND_DOWN    //向零方向舍入
ROUND_FLOOR    //向负无穷方向舍入
ROUND_HALF_DOWN    //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向下舍入, 例如1.55 保留一位小数结果为1.5
ROUND_HALF_EVEN    //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，如果保留位数是奇数，使用ROUND_HALF_UP，如果是偶数，使用ROUND_HALF_DOWN
ROUND_HALF_UP    //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向上舍入, 1.55保留一位小数结果为1.6,也就是我们常说的<code>“四舍五入”</code>
ROUND_UNNECESSARY    //计算结果是精确的，不需要舍入模式
ROUND_UP    //向远离0的方向舍入
需要对BigDecimal进行截断和四舍五入可用setScale方法

构造器，又称为构造方法。构造器用于构造该类的实例，也就是对象。
格式如下：[修饰符] 类名 (形参列表){//n条语句}
构造方法是一种特殊的方法，与一般的方法区别： 　　
1.构造方法的名字必须与定义他的类名完全相同，没有返回类型，甚至连void也没有。　　
2.构造方法的调用是在创建一个对象时使用new操作进行的。构造方法的作用是初始化对象。　
3.不能被static、final、synchronized、abstract和native修饰。构造方法不能被子类继承。　　
构造方法可以被重载。没有参数的构造方法称为默认构造方法，与一般的方法一样，构造方法可以进行任何活动，但是经常将他设计为进行各种初始化活动，比如初始化对象的属性。　
在Java中,任何变量在被使用前都必须先设置初值.Java提供了为类的成员变量赋初值的专门功能
（2）构造方法的调用是在创建一个对象时使用new操作进行的。构造方法的作用是初始化对象。举例如下：
Person p = new Person();
person()调用的就是Person的构造方法；

重载
1.构造器的重载
因为构造器的名字必须与类名相同，所以同一个类的所有构造器名肯定相同，构成重载；为了让系统能区分不同的构造器，多个构造器的参数列表必须不同。
class Person{
    int age;
    String name;
    public Person(){
    }
    public Person(int age){
        this.age = age;
    }
    public Person(int age,String name){
        this(age);
        this.name = name;
    }
}
2.方法的重载（overload）
1.定义：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或者参数类型不同即可。
两同一不同”：同一个类、相同方法名
参数列表不同：参数个数不同，参数类型不同
2.举例：
Arrays类中重载的sort() / binarySearch()
3.判断是否重载：
跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！
class Person{
    public void getSum(int i,int j){//A    
        System.out.println("憨憨");
    }
    public void getSum(double d1,double d2){//B
    }
    public void getSum(String s,int i){//形参先后顺序不同，也构成重载//C
    }
    public void getSum(int i,String s){//D
    }
    public void getSum(int i,int j){//与方法体无关！！！！
        return 0;
    }
    public void getSum(int m,int n){//与参数名无关！！！！
     
    }
    private void getSum(int i,int j){//与权限修饰符大小无关！！！！
     
    }
}

重写
为什么要重写：父类的功能无法满足子类的需求
方法重写的前提：必须要存在继承的关系！
应用：重写以后，当创建子类对象以后，通过子类对象调用子父类的同名参数的方法时，实际执行的时子类重写父类的方法
重写的规定：
方法的声明：权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型{
//方法体
}
A. 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同
B. 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
>特殊情况：子类不能重写父类中声明为private权限的方法
C. 返回值类型：
>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void
>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A的子类
//这样算重写，String是Object的子类
pulbic Object show(){//父类方法
}
public String show(){//子类方法
}
//这样不是重写，返回值类型不同
pulbic void catch(){//父类方法
}
pulbic int  catch(){//子类方法
}
>父类被重写的方法的返回值类型是基本数据类型(比如：double).则子类重写的方法的返回值类型必须是相同的（double）
D.子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型.（可以抛出异常类型更少、异常类型更小、不抛出异常）
子类和父类中的同名同参数的方法要么都声明为非static的(考虑重写)，要么都声明为static的(不是重写)。
E.静态方法不能被重写
原因：重写依赖于类的实例，而静态方法和类实例并没有什么关系。而且静态方法和类实例并没有什么关系。而且静态方法在编译时就已经确定，而方法重写是在运行时确定的(动态绑定)。（也可以说java多态体现在运行时、而static在编译时、与之相悖）
区分方法的重载和重写
重载：不表现为多态性。
重写：表现为多态性。
从编译和运行的角度来看：
重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数列表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。他们的调用地址在编译期间就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。
所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；
而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”；
重写规则补充
1.父类的抽象方法可以被子类通过两种途径重写(即实现和重写)。
2.父类的非抽象方法可以被重写为抽象方法(此时：子类必须为抽象类)。

Content-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，比如用PHP输出图片文件、JSON数据、XML文件等非HTML内容时，就必须用header函数来指定Content-Type，才能达到输出一张图片或是其它指定内容类型的需求。

StringUtils 方法的操作对象是 Java.lang.String 类型的对象，是 JDK 提供的 String 类型操作方法的补充，并且是 null 安全的(即如果输入参数 String 为 null 则不会抛出 NullPointerException ，而是做了相应处理，例如，如果输入为 null 则返回也是 null 等，具体可以查看源代码)。
StringUtils.isNotEmpty(String str)
判断某字符串是否非空，等于!isEmpty(String str)，这里不能排除空格字符
StringUtils.isNotEmpty(" ") = true
StringUtils.isNotBlank(String str)
判断某字符串是否不为空且长度不为0且不由空白符(whitespace)构成，等于!isBlank(String str)
StringUtils.isNotBlank(" ") = false
StringUtils.equals(String str1,String str2)
比较两个字符串是否相等，如果两个均为空则认为相等
StringUtils.trim(String str)
去除字符串两端的控制符，空字符串、null返回null
StringUtils.length

红黑树
二叉树简单来说就是每个非叶子节点都有且只有两个孩子，分别叫做左孩子和右孩子。
二叉树中有一类特殊的树叫二叉查找树，二叉查找树是一种有序的树，对于每个非叶子节点，其左子树的值都小于它，其右子树的值都大于它。
比二叉查找树更进一步的是二叉平衡树，二叉平衡树除了保证有序外，还能够保持每个节点左右子树的高度相差不超过1。常见的平衡树有AVL树，Treap，红黑树，伸展树，等等
红黑树是一种二叉查找树，但在每个节点上增加一个存储位表示节点的颜色，可以是RED或BLACK。通过对任何一条从根到叶子的路径上各个节点着色方式的限制，红黑树确保没有一条路径会比其他路径长出两倍，因而是接近平衡的。
红黑树满足一下5个性质：
每个节点是红色或者黑色；
根节点是黑色；
每个叶子节点NIL是黑色；
如果一个节点是红色，则它的两个孩子都是黑色；（每条路径上不能有两个连续的红色节点）
任一节点到其所有子孙叶子节点NIL的路径上包含相同数目的黑色节点。
注意，在红黑树中，把传统二叉树的叶子节点的孩子指向NIL，称NIL为红黑树中的叶子节点。NIL节点中含有指向父节点的指针，这可能是需要把null改为NIL的原因。

1、什么是HashMap？
HashMap基于哈希表的Map接口实现，是以 key-value 存储形式存在 ，HashMap 的实现不是同步的，这意味着它不是线程安全的。它的 key、value 都可以为 null，此外，HashMap 中的映射不是有序的。
2、HashMap的特性
Hash存储无序的
key和value都可以存储null值，但是key只能存唯一的一个null值
jdk8之前的数据结构是数组+链表，Jdk8之后变成数组+链表+红黑树
阀值大于8并且数组长度大于64才会转为红黑树
3、HashMap的数据结构
JDK7的情况，是数组加链接，hash冲突时候，就转换为链表
jdk8的情况，jdk8加上了红黑树，链表的数量大于8而且数组长度大于64之后，就转换为红黑树，红黑树节点小于6之后，就又转换为链表：
4、HashMap初始化操作

ConcurrentHashMap
ConcurrentHashMap(简称CHM)是在Java 1.5作为Hashtable的替代选择新引入的，是concurrent包的重要成员。
在Java 1.5之前，如果想要实现一个可以在多线程和并发的程序中安全使用的Map,只能在HashTable和synchronized Map中选择，因为HashMap并不是线程安全的。
但再引入了CHM之后，我们有了更好的选择。
CHM不但是线程安全的，而且比HashTable和synchronizedMap的性能要好。相对于HashTable和synchronizedMap锁住了整个Map，CHM只锁住部分Map。
CHM允许并发的读操作，同时通过同步锁在写操作时保持数据完整性。
ConcurrentHashMap并发度高的原因
ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。
不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。
每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。
就是说如果容量大小是16他的并发度就是16，可以同时允许16个线程操作16个Segment而且还是线程安全的。
public V put(K key, V value) {
    Segment<K,V> s;
    if (value == null)
        throw new NullPointerException();//这就是为啥他不可以put null值的原因
    int hash = hash(key);
    int j = (hash >>> segmentShift) & segmentMask;
    if ((s = (Segment<K,V>)UNSAFE.getObject          
         (segments, (j << SSHIFT) + SBASE)) == null) 
        s = ensureSegment(j);
    return s.put(key, hash, value, false);
}
他先定位到Segment，然后再进行put操作。
我们看看他的put源代码，你就知道他是怎么做到线程安全的了，关键句子我注释了。
        final V put(K key, int hash, V value, boolean onlyIfAbsent) {
          // 将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry
            HashEntry<K,V> node = tryLock() ? null :
                scanAndLockForPut(key, hash, value);
            V oldValue;
            try {
                HashEntry<K,V>[] tab = table;
                int index = (tab.length - 1) & hash;
                HashEntry<K,V> first = entryAt(tab, index);
                for (HashEntry<K,V> e = first;;) {
                    if (e != null) {
                        K k;
 // 遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。
                        if ((k = e.key) == key ||
                            (e.hash == hash && key.equals(k))) {
                            oldValue = e.value;
                            if (!onlyIfAbsent) {
                                e.value = value;
                                ++modCount;
                            }
                            break;
                        }
                        e = e.next;
                    }
                    else {
                 // 不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。
                        if (node != null)
                            node.setNext(first);
                        else
                            node = new HashEntry<K,V>(hash, key, value, first);
                        int c = count + 1;
                        if (c > threshold && tab.length < MAXIMUM_CAPACITY)
                            rehash(node);
                        else
                            setEntryAt(tab, index, node);
                        ++modCount;
                        count = c;
                        oldValue = null;
                        break;
                    }
                }
            } finally {
               //释放锁
                unlock();
            }
            return oldValue;
        }
首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁。
尝试自旋获取锁。
如果重试的次数达到了 MAX_SCAN_RETRIES 则改为阻塞锁获取，保证能获取成功。
get的逻辑
get 逻辑比较简单，只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。
由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。
ConcurrentHashMap 的 get 方法是非常高效的，因为整个过程都不需要加锁。
1.7虽然可以支持每个Segment并发访问，但是还是存在一些问题
是的，因为基本上还是数组加链表的方式，我们去查询的时候，还得遍历链表，会导致效率很低，这个跟jdk1.7的HashMap是存在的一样问题，所以他在jdk1.8完全优化了。
jdk1.8的数据结构
其中抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。
跟HashMap很像，也把之前的HashEntry改成了Node，但是作用不变，把值和next采用了volatile去修饰，保证了可见性，并且也引入了红黑树，在链表大于一定值的时候会转换（默认是8）。
ConcurrentHashMap值的存取操作以及是怎么保证线程安全的
根据 key 计算出 hashcode 。
判断是否需要进行初始化。
即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。
如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。
如果都不满足，则利用 synchronized 锁写入数据。
如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。
CAS是什么？自旋又是什么
CAS 是乐观锁的一种实现方式，是一种轻量级锁，JUC 中很多工具类的实现就是基于 CAS 的。
CAS 操作的流程如下图所示，线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。
这是一种乐观策略，认为并发操作并不总会发生。
就比如我现在要修改数据库的一条数据，修改之前我先拿到他原来的值，然后在SQL里面还会加个判断，原来的值和我手上拿到的他的原来的值是否一样，一样我们就可以去修改了，不一样就证明被别的线程修改了你就return错误就好了
CAS就一定能保证数据没被别的线程修改过么？
并不是的，比如很经典的ABA问题，CAS就无法判断了。就是说来了一个线程把值改回了B，又来了一个线程把值又改回了A，对于这个时候判断的线程，就发现他的值还是A，所以他就不知道这个值到底有没有被人改过，其实很多场景如果只追求最后结果正确，这是没关系的。
但是实际过程中还是需要记录修改过程的，比如资金修改什么的，你每次修改的都应该有记录，方便回溯。
怎么解决ABA问题？
用版本号去保证就好了，就比如说，我在修改前去查询他原来的值的时候再带一个版本号，每次判断就连值和版本号一起判断，判断成功就给版本号加1。
时间戳也可以，查询的时候把时间戳一起查出来，对的上才修改并且更新值的时候一起修改更新时间，这样也能保证，方法很多但是跟版本号都是异曲同工之妙
CAS性能很高，但是我知道synchronized性能可不咋地，为啥jdk1.8升级之后反而多了synchronized？
synchronized之前一直都是重量级的锁，但是后来java官方是对他进行过升级的，他现在采用的是锁升级的方式去做的。
针对 synchronized 获取锁的方式，JVM 使用了锁升级的优化方式，就是先使用偏向锁优先同一线程然后再次获取锁，如果失败，就升级为 CAS 轻量级锁，如果失败就会短暂自旋，防止线程被系统挂起。最后如果以上都失败就升级为重量级锁。
ConcurrentHashMap的get操作又是怎么样子的呢？
根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。
如果是红黑树那就按照树的方式获取值。
就不满足那就按照链表的方式遍历获取值。
1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（O(logn)），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的
一、创建ConcurrentHashMap对象
// 创建容量为8，负载系数为0.6的ConcurrentHashMap
ConcurrentHashMap<Key, Value> numbers = new ConcurrentHashMap<>(8, 0.6f);
Key - 用于关联Map中每个元素的唯一标识
Value - Map中每个元素，可以通过key值获取value
capacity容量 - 第一个参数表示这个map的容量是8，也就是说这个对象可以存储8个键值对
loadFactor负载因子 - 这个map对象的负载因子是 0.6. 这意味着，每当我们的哈希表被填满60%的时候，条目就会被移动到一个新的哈希表，其容量大小是原来哈希表的两倍。
默认情况下capacity=16，loadFactor=0.75
二、ConcurrentHashMap常用方法
2.1. 向ConcurrentHashMap插入元素
put(K,V) - 向map中插入key/value 键值对数据
putAll(map) - 把另一个map中的所有entries插入到当前的map中
putIfAbsent(K,V) - 向map中插入key/value 键值对数据，如果该键值对的key在map不存在则插入数据，否则不做操作。
2.2.批量获取ConcurrentHashMap 元素
entrySet()- 获取 map中key/value 键值对集合
keySet()- 获取map中所有的key的集合
values()- 获取map中所有的value的集合
2.3. 获取指定Key元素的value值
get() - 获取指定key元素的value值，如果key不存在返回null
getOrDefault() - 获取指定key元素的value值，如果key不存在返回一个指定的默认值
2.4.移除ConcurrentHashMap中的元素
remove(key) - 根据指定的key删除map中的元素，并将该元素返回
remove(key, value) - 只有当map中存在指定的键映射到指定的值时，才会从map中删除条目，并返回一个布尔值。返回true表示删除成功，否则表示map中没有这个键值对。

ArrayList和LinkedList区别
1.ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构；
2.对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针；
3.对于添加和删除操作add和remove，一般大家都会说LinkedList要比ArrayList快，因为ArrayList要移动数据。但是实际情况并非这样，对于添加或删除，LinkedList和ArrayList并不能明确说明谁快谁慢，下面会详细分析。
从源码可以看出，ArrayList想要get(int index)元素时，直接返回index位置上的元素，而LinkedList需要通过for循环进行查找，虽然LinkedList已经在查找方法上做了优化，比如index < size / 2，则从左边开始查找，反之从右边开始查找，但是还是比ArrayList要慢
ArrayList想要在指定位置插入或删除元素时，主要耗时的是System.arraycopy动作，会移动index后面所有的元素；LinkedList主耗时的是要先通过for循环找到index，然后直接插入或删除。
当数据量较小时，测试程序中，大约小于30的时候，两者效率差不多，没有显著区别；当数据量较大时，大约在容量的1/10处开始，LinkedList的效率就开始没有ArrayList效率高了，特别到一半以及后半的位置插入时，LinkedList效率明显要低于ArrayList，而且数据量越大，越明显。
ArrayList简介
ArrayList是一个其容量能够动态增长的动态数组。它继承了AbstractList，实现了List、RandomAccess, Cloneable, java.io.Serializable。
基本的ArrayList，长于随机访问元素，但是在List中间插入和移除元素时较慢。同时，ArrayList的操作不是线程安全的,一般在单线程中才使用ArrayList，而在多线程中一般使用Vector或者CopyOnWriteArrayList。
迭代器遍历
Iterator<Integer> it = arrayList.iterator();
while(it.hasNext()){
    System.out.print(it.next() + " ");
}
索引值遍历
for(int i = 0; i < arrayList.size(); i++){
   System.out.print(arrayList.get(i) + " ");
}
for循环遍历
for(Integer number : arrayList){
   System.out.print(number + " ");
}
需要说明的是，遍历ArrayList时，通过索引值遍历效率最高，for循环遍历次之，迭代器遍历最低
toArray()的使用
有时候，当我们调用ArrayList中的 toArray()，可能遇到过抛出java.lang.ClassCastException异常的情况，这是由于toArray() 返回的是 Object[] 数组，将 Object[] 转换为其它类型(如，将Object[]转换为的Integer[])则会抛出java.lang.ClassCastException异常，因为Java不支持向下转型。

什么是Stream流
Stream流是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。
Stream的优点：声明性，可复合，可并行。这三个特性使得stream操作更简洁，更灵活，更高效。
Stream的操作有两个特点：可以多个操作链接起来运行，内部迭代。
Stream可分为并行流与串行流，Stream API 可以声明性地通过 parallel() 与sequential() 在并行流与顺序流之间进行切换。
注意 ：
1、Stream不会自己存储数据。
2、Stream不会改变原对象，他们会返回一个新的Stream。
3、Stream操作是延迟的，他们会等到需要的结果时才执行。
4、使用并行流并不一定会提高效率，因为jvm对数据进行切片和切换线程也是需要时间的。
5.一个 Stream 只可以使用一次
流是字节序列的抽象概念。
文件是数据的静态存储形式，而流是指数据传输时的形态。
流类分为两个大类：节点流类和过滤流类（也叫处理流类）。
程序用于直接操作目标设备所对应的类叫节点流类，程序也可以通过一个间接流类去调用节点流类，以达到更加灵活方便地读取各种类型的数据，这个间接流类就是过滤流类（也叫处理流类），或者称为包装类。
Java中的"流"就是指把数据从一个对象移动到另一个对象的流动模式的抽象。其实Java的流模式用水流或者电流模型来解释是很容易理解的。
James Gosling的Java流模式图与水流模式图概念映射。数据源(data source)即水库，数据目的地(data destination)就是脸盆，数据(data)就是水，流(stream)实例化就是在管子中流动的水流。
输入流(input stream)就是用水泵从水库中抽出来要到水管中的水，输出流(output stream)经过水龙头将要达到脸盆中的水，计算机内存(memory)就是上图中的水流管道，关闭输入流(close input stream)就是关闭水泵开关，关闭输出流(close output stream)就是关闭关闭水龙头开关。
更进一步说，具体的水库和脸盆分别对应于Java中输入流对象和输出流对象。水流可以分成一粒一粒的水分子，这些水分子映射成计算机二进制位(bit)0/1，其组成的水滴映射成计算机字节流(字节是计算机储存信息的基本单位)。字节流和字符流在物理层面的实现都是比特流，二进制数据流可以认为是字节流，而字符流是遵循unicode编码规则的字节流。因此计算机中的"流"概念实际上就是指字节数据(bytes data)从源对象对按顺序流向目标对象的一种流动形式。
按照流的方向不同：分为输入流和输出流。
按照处理数据单位的不同：分为字节流（8位）和字符流（16位）。
字节流默认是不带缓冲区的，而字符流默认是带缓冲区的。
字节流是底层数据流，是数据有意义的最小单位。字符流是字节流的包装，底层实现是字节流。
字节流读取的时候，读到一个字节就返回一个字节；字符流使用了字节流读到一个或多个字节（中文对应的字节数是两个，在UTF-8码表中是3个字节）时。先去查指定的编码表，将查到的字符返回。
字节流可以处理所有类型数据，如：图片，MP3，AVI视频文件，而字符流只能处理字符数据。只要是处理纯文本数据，就要优先考虑使用字符流，除此之外都用字节流。文本文件可以用字节流来实现，当然使用字符流速度会更快。
字节输入流类：FileInputStream、BufferedInputStream和DataInputStream
FileInputStream:此类用于从本地文件系统中读取文件内容。
构造方法：
FileInputStream(File file):打开一个到实际文件的连接来创建一个FileInputStream，该文件通过文件系统中的File对象file指定。
FileInputStream(String name):打开一个到实际文件的连接来创建一个FileInputStream，该文件通过文件系统中的路径名name指定。
常用方法：
int available():返回下一次对此输入流调用的方法不受阻塞地从此输入流读取（或跳过）的估计剩余字节数。
void close():关闭此文件输入流并释放与该流关联的所有系统资源。
BufferedInputStream：此类本身带有一个缓冲区，在读取数据时，先放到缓冲区中，可以减少对数据源的访问，提高运行的效率。
构造方法：
BufferedInputStream(InputStream in):创建一个BufferedInputStream并保存其参数，即输入流in，以便将来使用。
BufferedInputStream(InputStream in,int size):创建一个具有指定缓冲区大小的BufferedInputStream并保存其参数，即输入流in，以便将来使用。
常用方法：
int available():返回下一次对此输入流调用的方法不受阻塞地从此输入流读取（或跳过）的估计剩余字节数。
void close():关闭此输入流并释放与该流关联的所有系统资源。
int read():从输入流中读取数据的下一个字节。
int read(byte[] b,int off,int len):从此字节输入流中给定偏移量处开始将各字节读取到指定的byte数组中。
DataInputStream:该类提供一些基于多字节读取方法，从而可以读取基本数据类型的数据。

构造方法：
DataInputStream(InputStream in):使用指定的底层InputStream创建一个DataInputStream。
常用方法：
int read(byte[] b):从包含的输入流中读取一定数量的字节，并将它们存储到缓冲区数组b中。
int read(byte[] b,int off,int len):从包含的输入流中将最多len个字节读入一个byte数组中。

字节输出流类：FileOutputStream、BufferedOutputStream和DataOutputStream
FileOutputStream:此类用于从本地文件系统的文件中写入数据。

构造方法：
FileOutputStream(File file):创建一个向指定File对象表示的文件中写入数据的文件输出流。FileOutputStream(String name):创建一个向具有指定名称的文件中写入数据的输出文件流。
常用方法：
void close():关闭此文件输出流并释放与此流有关的所有系统资源。
FileDescriptor getFD():返回与此流有关的文件描述符。
void write(byte[] b):将b.length个字节从指定byte数组写入此文件输出流中。
void write(byte[] b,int off,int len):将指定byte数组中从偏移量off开始的len个字节写入此文件输出流。
void write(int b):将指定字节写入此文件输出流。
BufferedOutputStream:此类本身带有一个缓冲区，在写入数据时，先放到缓冲区中，实现缓冲的数据流。

构造方法：
BufferedOutputStream(OutputStream out):创建一个新的缓冲输出流，来将数据写入指定的底层输入流。
BufferedOutputStream(OutputStream out,int size):创建一个新的缓冲输出流，来将具有指定缓冲区大小的数据写入指定的底层输出流。
常用方法：
void flush():刷新此缓冲的输出流。
void write(byte[] b,int off,int len):将指定byte数组中从偏移量off开始的len个字节写入此缓冲的输出流。
void write(int b):将指定的字节写入此缓冲的输出流。
DataOutputStream(OutputStream out):创建一个新的数据输出流，将数据写入指定基础输出流。

常用方法：
void flush():清空此数据输出流。
int size()：返回计数器written的当前值，即到目前为止写入此数据输出流的字节数。
void write(byte[] b,int off,int len):将指定byte数组中从偏移量off开始的len个字节写入基础输出流。
void write(int b):将指定字节（参数b的八个低位）写入基础输出流。
2、字符流
FileReader:用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的

构造方法：
FileReader(File file):在给定从中读取数据的File的情况下创建一个新的FileReader。FileReader(String fileName):在给定从中读取数据的文件名的情况下创建一个新的FileReader。

BufferedReader类是Reader类的子类，为Reader对象添加字符缓冲器，为数据输入分配内存存储空间，存取数据更为有效。

构造方法：
BufferedReader(Reader in):创建一个使用默认大小输入缓冲区的缓冲字符输入流。
BufferedReader(Reader in,int sz):创建一个使用指定大小输入缓冲区的缓冲字符输入流。

操作方法：
void close():关闭该流并释放与之关联的所有资源。
void mark(int readAheadLimit):标记流中的当前为止。
boolean markSupported();判断此流是否支持mark()操作。
int read():读取单个字符。
int read(char[] cbuf,int off,int len):将字符读入数组的某一部分。
String readLine():读取一个文本行。
boolean ready():判断此流是否已准备好被读取。
void reset():将流重置到最新的标记。
long skip(long n):跳过字符。
FileWriter:用来写入字符文件的便捷类，可用于写入字符流。
构造方法：
FileWriter(File file):根据给定的File对象构造一个FileWriter对象。
FileWriter(String filename):根据给定的文件名构造一个FileWriter对象。
BufferedWriter: 将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。
缓冲流的目的:
操作流的时候，习惯定义一个byte/char数组。
int read(): 每次都从磁盘文件中读取一个字节。 直接操作磁盘文件性能极低。
解决方案：定义一个数组作为缓冲区。
byte[] buffer = new byte[1024]；该数组其实就是一个缓冲区。
一次性从磁盘文件中读取1024个字节。如此以来，操作磁盘文件的次数少了，性能得以提升。提供的默认缓存区大小是8192(1024*8)，我们一般不用修改大小
public class BufferStreamDemo {
    public static void main(String[] args) throws Exception {
        File file = new File("file/aaa.txt");
        BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));
        out.write("中国".getBytes());
        out.close();
        BufferedInputStream in = new BufferedInputStream(new FileInputStream(file));
        byte[] buffer = new byte[1024];
        int len = -1;
        while((len = in.read(buffer)) != -1){
            System.out.println(new String(buffer, 0, len));
        }
        in.close();
    }
}
public class BufferCharacterDemo {
    public static void main(String[] args) throws Exception {
        File file = new File("file/aaa.txt");
        BufferedWriter in = new BufferedWriter(new FileWriter(file,true));
        in.newLine();//用来换行等同于‘\n'
        in.write("美国");
        in.newLine();
        in.write("马来西亚");
        in.close();
        BufferedReader out = new BufferedReader(new FileReader(file));
        String line = null;
        //按行读取
        while((line = out.readLine()) != null){
            System.out.println(line);
        }
        out.close();
    }
}
按照功能不同：分为节点流和处理流。节点流(又称低级流)、过滤流(又称高级流、处理流、包装流)
节点流：是可以从一个特定的数据源（节点）读写数据的流（例如文件，内存）。就像是一条单一的管子接到水龙头上开始放水。
处理流：是“连接”在已经存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。就像在已经接了一条管子（节点流）的基础上，又套上几个更粗，具有特殊功能的管子（处理流）对流出的水进一步的处理。
四种基本流InputStream，OutputStream，Reader，Writer又分别有更具体的子类，分为文件流，缓冲流，数据流，转换流，Print流，Object流等，都分别有特定的功能或用来操作特定的数据。其中深颜色的代表节点流，浅颜色的代表处理流。
节点流分别对File（文件），Array（内存中的一个数组），String（字符串），Pipe（管道）进行处理。
常用的处理流有：缓冲流，转换流，数据流，对象流，打印流。
节点流(Node Stream)是流管道两端直接连接data source和data destination上的，即为取放数据的真实载体，在流通道本身不对数据做任何加工，因而也被称为低级流。

节点流从一个特定的数据源读写数据。即节点流是直接操作文件，网络等的流，例如FileInputStream和FileOutputStream，他们直接从文件中读取或往文件中写入字节流。
“连接”在已存在的流（节点流或处理流）之上通过对数据的处理为程序提供更为强大的读写功能。过滤流是使用一个已经存在的输入流或输出流连接创建的，过滤流就是对节点流进行一系列的包装。例如BufferedInputStream和BufferedOutputStream，使用已经存在的节点流来构造，提供带缓冲的读写，提高了读写的效率，以及DataInputStream和DataOutputStream，使用已经存在的节点流来构造，提供了读写Java中的基本数据类型的功能。他们都属于过滤流。
public static void main(String[] args) throws IOException {
        // 节点流FileOutputStream直接以A.txt作为数据源操作
        FileOutputStream fileOutputStream = new FileOutputStream("A.txt");
        // 过滤流BufferedOutputStream进一步装饰节点流，提供缓冲写
        BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(
                fileOutputStream);
        // 过滤流DataOutputStream进一步装饰过滤流，使其提供基本数据类型的写
        DataOutputStream out = new DataOutputStream(bufferedOutputStream);
        out.writeInt(3);
        out.writeBoolean(true);
        out.flush();
        out.close();
        // 此处输入节点流，过滤流正好跟上边输出对应，读者可举一反三
        DataInputStream in = new DataInputStream(new BufferedInputStream(
                new FileInputStream("A.txt")));
        System.out.println(in.readInt());
        System.out.println(in.readBoolean());
        in.close();
}
FileOutputStream是根据二进制010101一个一个字节处理
BufferedOutputStream是对字节封装成buffered，以缓冲区处理
DataOutputStream是以字符串形式，类似（“hello”）处理。
缓冲流：要套接在相应的字节流之上，对读写的数据提供了缓冲功能，提高了读写的效率，同时也增加了一些更方便方法。
缓冲流的作用就像一个桶，原本的字节流是个水管，水管直接连到目的地，加了缓冲流之后，就是在水管下接了一个桶，等桶接满水后再倒入目的地。起到了缓冲的作用。这样就可以一次读到更多的数据，避免了频繁的读写硬盘。由于带了缓冲功能，所以就写数据的时候需要使用flush方法。
import java.io.*; 
public class TestBufferStream{ 
  public static void main(String[] args){ 
    try{ 
       BufferedWriter bw=new BufferedWriter(new FileWriter("F:\\Java\\IO\\dat.txt"));//在对写文件的字节流上套接上缓冲流 
       BufferedReader br=new BufferedReader(new FileReader("F:\\Java\\IO\\dat.txt"));//在对读文件的字节流上套接上缓冲流 
       String s=null; 
       for(int i=1;i<=100;i++){ 
        s=String.valueOf(Math.random());//通过随机函数给s赋值 
        bw.write(s);          //将s写入到dat.txt文件中 
        bw.newLine();          //写入一个分行符。缓冲流比较好用的方法就是可以写入或读取一行的数据。 
       } 
       bw.flush();            //使内存中的所有数据立刻写出，不再缓冲。 
       while((s=br.readLine())!=null){  //按行读取文件内容 
        System.out.println(s); 
       } 
       bw.close();            //关闭处理流同时关闭里面的节点流。 
       br.close(); 
        
    } 
    catch(IOException e){ 
       e.printStackTrace(); 
    } 
  } 
} 
转换流：用与字节数据到字符数据之间的转化。InputStreamReader需要和InputStream套接，OutputStreamWriter需要和outputStream套接。
数据流：DataInputStream 和DataOutputStream.提供将基础数据类型写入到文件中，或者读取出来，这个流的用处还是很大的，如果没有这种流的话，有一个long，本身只占8个字节，如果我要写入到文件，需要转成字符串，然后在转成字符数组，那空间会占用很多，但是有了这种流之后就很方便了，直接将这8个字节写到文件就可以了，既节约了内存空间也使程序写起来更加方便简单。但是读取的时候需要注意了，根据读取的数据类型，指针会往下移，所以你读的顺序必须要和写的顺序一致才能完成你正确的需求。否则就相当与把数据拆分了。
import java.io.*; 
public class TestDataStream{ 
   public static void main(String[] args){ 
     ByteArrayOutputStream baos=new ByteArrayOutputStream();  //建一个节点流。 
     DataOutputStream dos=new DataOutputStream(baos);     //在节点流上接一根数据流“管道”                  try{ 
       dos.writeDouble(Math.random());            //double型 ，占8个字节  
       dos.writeBoolean(true);                //boolean型，占一个字节 
       ByteArrayInputStream bais=new ByteArrayInputStream(baos.toByteArray());  
       System.out.println(bais.available());         //输出流中总的可用字节数--9 
       DataInputStream dis=new DataInputStream(bais);    //同样在输出流的外面接上数据流“管道” 
       System.out.println(dis.readDouble());         //直接读出double型的数 
       System.out.println(dis.readBoolean());        //直接读出boolean型 
       dos.close(); 
       dis.close(); 
     }catch(IOException e){ 
       e.printStackTrace(); 
     } 
  
   } 
} 
打印流：java.io中专门提供用于打印的流，这类流在写入的时候有自动flush的功能，所以不需要每打印一个东西都flush一次。
import java.io.*; 
public class TestPrintStream1{ 
    public static void main(String[] args){ 
      PrintStream ps=null; 
      try{ 
       FileOutputStream fos=new FileOutputStream("F:\\Java\\IO\\log.dat");//创建输出流，指定输出地点 
       ps=new PrintStream(fos);                      //在流外面包装打印流 
      }catch(IOException e){ 
       e.printStackTrace(); 
      } 
      if(ps!=null){ 
       System.setOut(ps);                         //将系统的打印设置成打印流ps 
      } 
      int ln=0; 
      for(char c=0;c<=60000;c++){ 
        System.out.print(c+" ");                     //不在打印到dos窗口，输出流直接打印到指定文件中 
        if(ln++>=100){ 
           System.out.println();ln=0; 
        } 
      } 
    } 
} 
创建Stream
创建Stream，就是将一个数据源 （如：集合、数组）转化为一个流。
1、通过Collection系列提供的stream()（串行） 或parallelStream()（并行）获取数据流。
2、通过Arrays中的静态方法stream() 获取数据流。
3、通过Stream类中的静态方法of()获取数据流。
//1、通过Collection系列提供的stream()（串行） 或parallelStream()（并行）获取
   List<String> list = new ArrayList<>();
   Stream<String> stream1 = list.stream();//串行流
   Stream<String> stream2 = list.parallelStream();//并行流
 //2、通过Arrays中的静态方法stream() 获取数据流
   User[] u = new User[2];
   Stream<User> stream3 = Arrays.stream(u);
 //3、通过Stream；类中的静态方法of()
   Stream<String> stream4 = Stream.of("11","2");
中间操作
中间操作，即对数据源进行一系列的操作处理。
多个中间操作可以连接起来性格一条流水线，除非流水线上触发器终止操作，否则中间操作不会执行任何的处理，而是在终止操作时一次性全部处理，成为惰性求值。
//创建无限流
//迭代
Stream<Integer> integerStream = Stream.iterate(0,(x) -> x+2);
//中间操作
integerStream.limit(10).forEach(System.out::println);
筛选filter和切片
1、filter(predicate)-接收lambda，从流中排除某些元素。
2、limit(n)-截断流，使其元素不超过给定数量。
3、skip(n)-跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流，与limit(n)互补。
4、distinct-筛选，通过流所生成元素的hashcode()和equals()去重复元素。
/**
   * 打印年龄大于18的前4位用户信息（不重复）
   * 并跳过第1个用户
   */
@Test
  public void test1(){
    list.stream()
    .filter((x)->x.getAge()>18)
    .distinct()
    .limit(4)
    .skip(1).forEach(System.out::println);
  }
List<String> strings = Arrays.asList("Hollis", "", "HollisChuang", "H", "hollis"); 
strings.stream().filter(string -> !string.isEmpty()).forEach(System.out::println); 
//Hollis, , HollisChuang, H, hollis
映射
1、map，接收Lambda，将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每一个元素上，并将其映射成一个新的元素。
2、mapToDouble/mapToInt/mapToLong，接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream/IntStream/LongStream。
3、flatMap，接收一个函数作为参数，将流中的每个值都换成一个流，然后把流连接成一个流。
@Test
 public void test2(){
   ///map
   list.stream().map(User::getName)
   .forEach(System.out::println);
   //flatMap
   List<List<User>> list1 = new ArrayList<>();
   list1.add(list);
   list1.stream().flatMap(Stream::getNames)
   .forEach(System.out::println);
 }
 public static Stream<String> getNames(List<User> list){
   List<String> list1 = new ArrayList<String>();
   for (User user : list) {
     list1.add(user.getName());
   }
   return list1.stream();
 }
List<Integer> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); 
numbers.stream().map( i -> i*i).forEach(System.out::println); 
//9,4,4,9,49,9,25
排序
1、sorted()，产生一个新流，其中按自然顺序排序。
2、sorted(Comparator)，产生一个新流，其中按比较器顺序排序。
@Test
  public void test3(){
    List<String> list =Arrays.asList("aa","bb","cc","dd");
    list.stream().sorted()
    .forEach(System.out::println);
    //
    list.stream().sorted((x,y) -> {
      if(x.equals(y)){
        return 1;
      }else{
        return -1;
      }
    } ).forEach(System.out::println);
  }
终止操作
终止操作是执行中间操作链，并产生结果（一个新流）,数据源本身并不受影响，其结果可以是任何不是流的值。
//创建无限流
//迭代
Stream<Integer> integerStream = Stream.iterate(0,(x) -> x+2);
//终止操作
integerStream.forEach(System.out::println);
forEach
Stream 提供了方法 'forEach' 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：
Random random = new Random(); 
random.ints().limit(10).forEach(System.out::println);
count
count用来统计流中的元素个数。
List<String> strings = Arrays.asList("Hollis", "HollisChuang", "hollis","Hollis666", "Hello", "HelloWorld", "Hollis"); 
System.out.println(strings.stream().count()); 
//7
collect
collect就是一个归约操作，可以接受各种做法作为参数，将流中的元素累积成一个汇总结果：
List<String> strings = Arrays.asList("Hollis", "HollisChuang", "hollis","Hollis666", "Hello", "HelloWorld", "Hollis"); 
strings = strings.stream().filter(string -> string.startsWith("Hollis")).collect(Collectors.toList()); 
System.out.println(strings); 
//Hollis, HollisChuang, Hollis666, Hollis
查找与匹配
1、allMatch,检查是否匹配所有元素。
2、anyMatch,检查是否至少匹配一个元素。
3、noneMatch,检查是否没有匹配所有元素。
4、findFirst,返回第一个元素。
5、findAny,返回当前流中的任意元素。
6、count,返回流中元素的总数。
7、max,返回流中最大值。
8、min,返回流中最小值。
9、froEach(Consumer c) 内部迭代。
@Test
  public void test4(){
    boolean b = list.stream().
        noneMatch((e) ->
        e.getName().equals("zhao"));
    System.out.println(b);
    Optional<User> op = list.parallelStream()
        .filter((x) -> x.getAge() == 18)
        .findAny();
    System.out.println(op.get());
  }
归约
reduce，可以将流中的值反复结合起来，得到一个值。
6.转换大写
public void test7() {
 List<String> list = Arrays.asList("a", "MnM");
 
 List<String> result = list.stream().
 map(String::toUpperCase).
 collect(Collectors.toList());
 System.out.println(list);
 System.out.println(result);
 }
输出
[a, MnM]
[A, MNM]
7.平方
public void test8() {
 List<Integer> list2 = Arrays.asList(1, 2, 4);
 List<Integer> list3 = list2.stream().
 map(key -> key * key).
 collect(Collectors.toList());
 System.out.println(list2);
 System.out.println(list3);
 }
输出
[1, 2, 4]
[1, 4, 16]
8.找偶数
public void test8_5() {
 List<Integer> list2 = Arrays.asList(1, 2, 4);
 List<Integer> list3 = list2.stream().
 filter(key -> key % 2 == 0).
 collect(Collectors.toList());
 System.out.println(list2);
 System.out.println(list3);
 }
9.区间值
public void test5() {
 System.out.println("\n");
 IntStream.range(1, 3).forEach(System.out::println);
 System.out.println("\n");
 IntStream.rangeClosed(1, 3).forEach(System.out::println);
 }
结果
1
2
 
 
1
2
3
10.并发
public void test5_pa() {
IntStream.rangeClosed(1, 10).parallel().forEach(System.out::println);
}
输出
3
7
1
5
2
8
10
6
9
4
11. 新的Stream继续操作
public void test6_6() {
 Stream.of("one", "two", "three", "four")
 .filter(e -> e.length() > 3)
 .peek(e -> System.out.println("Filtered value: " + e))
 .map(String::toUpperCase)
 .peek(e -> System.out.println("Mapped value: " + e))
 .collect(Collectors.toList());
 }
结果
Filtered value: three
Mapped value: THREE
Filtered value: four
Mapped value: FOUR
12. Optional
public static void print(String text) {
 System.out.println("<<<<<<");
 System.out.println(Optional.ofNullable(text));
 List<String> obj = new ArrayList<>();
 Optional.ofNullable(text).ifPresent(System.out::println);
 System.out.println(">>>>>>>>>>>>\n");
 }
 public static int getLength(String text) {
 return Optional.ofNullable(text).map(String::length).orElse(-1);
 }
 
 public void test14() {
 String strA = " abcd ", strB = null;
 print(strA);
 print("");
 print(strB);
 
 System.out.println(getLength(strA));
 System.out.println(getLength(""));
 System.out.println(getLength(strB));
 }
结果

<<<<<<
Optional[ abcd ]
 abcd
>>>>>>>>>>>>
 
<<<<<<
Optional[]
 
>>>>>>>>>>>>
 
<<<<<<
Optional.empty
>>>>>>>>>>>>
 
6
0
-1
13. 字符串拼接、最值、求和、过滤
public void test15() {
 String concat = Stream.of("A", "B", "C").reduce("", String::concat);
 System.out.println("concat:" + concat);
 
 double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min);
 System.out.println("min:" + minValue);
 
 int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);
 System.out.println("sum1:" + sumValue);
 
 int sumValue2 = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();
 System.out.println("sum2:" + sumValue2);
 
 concat = Stream.of("a", "B", "c", "D", "e", "F").filter(x -> x.compareTo("Z") > 0).reduce("", String::concat);
 System.out.println("concat:" + concat);
 }
结果
concat:ABC
min:-3.0
sum1:10
sum2:10
concat:ace
14. limit, skip
public void test16() {
 List<Person> persons = new ArrayList<>();
 IntStream.range(1, 1000).forEach(key->persons.add(new Person(key, "jihite:" + key)));
 List<String> personList = persons.stream().map(Person::getName).limit(10).skip(3).collect(Collectors.toList());
 System.out.println(personList);
 }
输出
[jihite:4, jihite:5, jihite:6, jihite:7, jihite:8, jihite:9, jihite:10]
15.找出最长一行的长度
public void test19() throws IOException {
 String path = "**/Person.java";
 BufferedReader br = new BufferedReader(new FileReader(path));
 int longest = br.lines()
 .mapToInt(String::length)
 .max()
 .getAsInt();
 br.close();
 System.out.println(longest);
 }
输出
16.找出全文的单词，转小写，并排序
public void test20() throws IOException {
 String path = "**/Person.java";
 BufferedReader br = new BufferedReader(new FileReader(path));
 List<String> words = br.lines()
 .flatMap(line->Stream.of(line.split(" ")))
 .filter(word->word.length()>0)
 .map(String::toLowerCase)
 .distinct()
 .sorted()
 .collect(Collectors.toList());
 br.close();
 System.out.println(words);
 words.forEach(key-> System.out.println(key));
 }
输出
*
*/
/**
//
2018/10/24
21:40
=
@author:
@date:
@description:
class
getname()
int
name)
filter
filter
用于对Stream中的元素进行过滤，返回一个过滤后的Stream
其方法定义如下：
Stream<T> filter(Predicate<? super T> predicate);
使用示例：
Stream<String> s = Stream.of("test", "t1", "t2", "teeeee", "aaaa");
//查找所有包含t的元素并进行打印
s.filter(n -> n.contains("t")).forEach(System.out::println);
map
元素一对一转换。
它接收一个Funcation参数，用其对Stream中的所有元素进行处理，返回的Stream对象中的元素为Function对原元素处理后的结果
其方法定义如下：
<R> Stream<R> map(Function<? super T, ? extends R> mapper);
示例，假设我们要将一个String类型的Stream对象中的每个元素添加相同的后缀.txt，如a变成a.txt，其写法如下：
Stream<String> s = Stream.of("test", "t1", "t2", "teeeee", "aaaa");
s.map(n -> n.concat(".txt")).forEach(System.out::println);
flatMap
元素一对多转换：对原Stream中的所有元素使用传入的Function进行处理，每个元素经过处理后生成一个多个元素的Stream对象，然后将返回的所有Stream对象中的所有元素组合成一个统一的Stream并返回；
方法定义如下：
<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);
示例，假设要对一个String类型的Stream进行处理，将每一个元素的拆分成单个字母，并打印：
Stream<String> s = Stream.of("test", "t1", "t2", "teeeee", "aaaa");
s.flatMap(n -> Stream.of(n.split(""))).forEach(System.out::println);
takeWhile
方法定义如下：
default Stream<T> takeWhile(Predicate<? super T> predicate)
如果Stream是有序的（Ordered），那么返回最长命中序列（符合传入的Predicate的最长命中序列）组成的Stream；如果是无序的，那么返回的是所有符合传入的Predicate的元素序列组成的Stream。
与Filter有点类似，不同的地方就在当Stream是有序时，返回的只是最长命中序列。
如以下示例，通过takeWhile查找”test”, “t1”, “t2”, “teeeee”, “aaaa”, “taaa”这几个元素中包含t的最长命中序列：
Stream<String> s = Stream.of("test", "t1", "t2", "teeeee", "aaaa", "taaa");
//以下结果将打印： "test", "t1", "t2", "teeeee"，最后的那个taaa不会进行打印 
s.takeWhile(n -> n.contains("t")).forEach(System.out::println);

MyBatis
MyBatis是一个支持普通sql查询，存储过程和高级映射的优秀持久层框架。MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索封装。MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。
<mapper namespace="me.gacl.mapping.userMapper">
为这个mapper指定一个唯一的namespace，namespace的值习惯上设置成包名+sql映射文件名，这样就能够保证namespace的值是唯一的
例如namespace="me.gacl.mapping.userMapper"就是me.gacl.mapping(包名)+userMapper(userMapper.xml文件去除后缀)
<select id="getUser" parameterType="int"
    resultType="me.gacl.domain.User">
    select * from users where id=#{id}
</select>
在select标签中编写查询的SQL语句， 设置select标签的id属性为getUser，id属性值必须是唯一的，不能够重复
使用parameterType属性指明查询时使用的参数类型，resultType属性指明查询返回的结果集类型
resultType="me.gacl.domain.User"就表示将查询结果封装成一个User类的对象返回
User类就是users表所对应的实体类

算法效率
在使用当中，算法效率分为两种，一是时间效率(时间复杂度)，二是空间效率(空间复杂度)。时间复杂度是指程序运行的速度。空间复杂度是指一个算法所需要的额外的空间。
时间复杂度
计算程序运行的时间不能拿简单的时间来计算，因为不同处理器处理数据的能力是不一样的。所以只算一个大概的次数就行了，俨然就是算法中的基本操作的执行次数。用大O的渐进法来表示
void func1(int N){
    int count = 0;
    for (int i = 0; i < N ; i++) {
        for (int j = 0; j < N ; j++) {
            count++;
        }
    }
    for (int k = 0; k < 2 * N ; k++) {
        count++;
    }
    int M = 10;
    while ((M--) > 0) {
        count++;
    }
    System.out.println(count);
}
func1 的基本执行次数是：F(N) = N^2 + 2*N + 10
推导大O阶的方法
1、用常数1取代运行时间中的所有加法常数。
2、在修改后的运行次数函数中，只保留最高阶项。
3、如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。
所以使用大 O 的渐进法表示之后，func1 的时间复杂度就是：O(N^2)
算法情况
因为当我们用算法计算的时候，会有最好情况和最坏情况和平均情况。我们常说的时间复杂度在 O(N) 这里的时间复杂度就是最坏情况。
最好情况就是最小的运行次数。
void func2(int N){
    int count = 0;
    for (int k = 0; k < 2 * N ; k++) {
        count++;
    }
    int M = 10;
    while ((M--) > 0) {
        count++;
    }
    System.out.println(count);
}
这里的结果是 O(N) 因为根据时间复杂度的计算方法，去除常数，所以 2*N 就是 N 。M 是 10 也可以忽略掉。
void func3(int N, int M) {
    int count = 0;
    for (int k = 0; k < M; k++) {
        count++;
    }
    for (int k = 0; k < N ; k++) {
        count++;
    }
    System.out.println(count);
}
这里的时间复杂度是 O(M+N) 因为 M 和 N 的值是未知的，所以是 O(M+N)
void func4(int N) {
    int count = 0;
    for (int k = 0; k < 100; k++) {
        count++;
    }
    System.out.println(count);
}
这个的时间复杂度是 O(1) 因为循环里面是常数，所以根据大 O 渐进法，结果就是 O(1)
计算冒泡排序的时间复杂度
public static void bubbleSort(int[] arr){
    for (int i = 0; i < arr.length; i++) {
        for (int j = 0; j < arr.length - 1 - i; j++) {
            if(arr[j] > arr[j+1]){
                int tmp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tmp;
            }
        }
    }
}
因为冒泡排序的特殊性，可能一次就排好了，也可能得一直排到最后，所以就有了最好情况和最坏情况。
最好情况：就是比较一次，就是 O(N)
最坏情况：一直排到最后，就是 O(N^2)
计算二分查找的时间复杂度
int binarySearch(int[] array, int value) {
    int begin = 0;
    int end = array.length - 1;
    while (begin <= end) {
        int mid = begin + ((end-begin) / 2);
        if (array[mid] < value)
            begin = mid + 1;
        else if (array[mid] > value)
            end = mid - 1;
        else
            return mid;
    }
    return -1;
}
因为二分查找是一半一半的找，所以每次查找之后都会把查找范围减半，比如说在一个 1 - 8 的有序数组里面查找 8 也就是查找最坏情况。
如图，在数组当中完成二分查找需要log2n - 1次也就是时间复杂度是log2n（就是log以2为底n的对数）
计算阶乘递归的时间复杂度
long factorial(int N) {
    return N < 2 ? N : factorial(N-1) * N;
}
计算递归的时间复杂度：递归的次数 * 每次递归执行的次数。
所以这次递归的时候，基本操作递归了 N 次，所以时间复杂度就是 O(N)
计算斐波那契递归的时间复杂度
int fibonacci(int N) {
    return N < 2 ? N : fibonacci(N-1)+fibonacci(N-2);
}
所以就有公式可以计算出每次计算的次数，就是：2 ^ (n - 1) ，所以计算的结果就是：2^\0 + 2^1 + 2^2 + 2^3……2^(n-1) = 2^n+1 所以按照大 O 渐进法来算，结果就是：2^n 。
所以斐波那契数列的时间复杂度就是：2^n 。
空间复杂度
空间复杂度衡量的是一个算法在运行过程当中占用的额外存储空间的大小，因为没必要按照字节来算，而是算变量的个数。也是用大O渐进法表示。
计算冒泡排序的空间复杂度
public static void bubbleSort(int[] arr){
    for (int i = 0; i < arr.length; i++) {
        for (int j = 0; j < arr.length - 1 - i; j++) {
            if(arr[j] > arr[j+1]){
                int tmp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = tmp;
            }
        }
    }
}
因为冒泡排序的变量并没有变化，使用的是额外空间是常数，所以空间复杂度是O(1)。
计算斐波那契数列的空间复杂度（非递归）
int[] fibonacci(int n) {
    long[] fibArray = new long[n + 1];
    fibArray[0] = 0;
    fibArray[1] = 1;
    for (int i = 2; i <= n ; i++) {
        fibArray[i] = fibArray[i - 1] + fibArray [i - 2];
    }
    return fibArray;
}
因为这里的斐波那契数列开辟了 n 个额外空间，所以空间复杂度为 O(n) 。
计算阶乘递归Factorial的时间复杂度
int factorial(int N) {
    return N < 2 ? N : factorial(N-1)*N;
}
因为是递归，每次递归都会开辟栈帧，每个栈帧占用常数个空间，所以空间复杂度就是 O(N) 。



反射
反射(Reflection)是java被视为动态语言的关键，反射机制允许程序在运行时（注意不是编译的时候）借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。
优缺点：具有灵活性但是效率较低。
反射提高了Java程序的灵活性和扩展性，降低耦合性，提高自适应能力。它允许程序创建和控制任何类的对象，无需提前硬编码目标类
因为是JVM操作，所以对于性能来说会有所下降。容易对程序源码造成一定的混乱。
反射机制的应用:
生成动态代理,面向切片编程(在调用方法的前后各加栈帧).
在编译时根本无法知道该对象或类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息
可以通过外部文件配置，在不修改源码的情况下，来控制程序（这就是开闭原则）
在运行时判断任意一个对象所属的类
在运行时构造任意一个类的对象（实例化）
在运行时判断任意一个类所具有的成员变量和方法
在运行时调用任意一个对象的方法——动态代理
反射机制的原理:
1首先明确的概念: 一切皆对象----类也是对象.
2然后知道类中的内容 :modifier constructor field method.
3其次明白加载: 当Animal.class在硬盘中时,是一个文件,当载入到内存中,可以认为是一个对象,是java.lang.class的对象.
想要去实现反射想要借助一些类分别是 class，Constructor，Field，Method;
java 获取反射常使用的三种方式：
1.通过new对象实现反射机制
通过Object类的getClass方法来获取
2.通过路径实现反射机制
使用Class.forName方法
3.通过类名实现反射机制
使用.class的方式
1、Class类
Class类的实例表示正在运行的Java应用程序中的类和接口。Class没有公共的构造方法，Class对象是在加载类时由Java虚拟机以及通过调用类加载器中的defineClass方法自动构造的
Constructor提供关于类的单个构造方法的信息以及对它的访问权限(主要提供的是对构造方法使用)
Method提供关于类或接口上单独某个方法（以及如何访问该方法）的信息。所反映的方法可能是类方法或实例方法（包括抽象方法)
Field主要提供对类中的成员变量的访问和使用
Class类也使用了泛型，即是Class
某个类的属性、方法和构造器、某个类实现了哪些接口，JRE都为其保留了一个不变的Class类型的对象，同一个类的所有对象共享同一个Class对象。
Class本身也是一个类
Class对象只能由系统建立对象
一个加载的类在JVM中只会有一个Class实例
一个Class对象对应的是一个加载到JVM中的一个class文件
每个类的实例都会记得自己是由哪个Class实例所生成
通过Class可以完整地得到一个类中的所有被加载结构
Class类是Reflection的根源，针对任何想动态加载、运行的类，唯有先获得相应的Class对象
2、通过反射获取Class对象：
所有的类都可以通过反射获取其Class对象。
下面通过例子列举获取类的Class对象的三种方式：
//新建Person类
class Person{
    String name;
    int age;
    int id;
 
 public Person() {
 }
 public Person(String name, int age) {
 this.name = name;
 this.age = age;
 }
 public String getName() {
 return name;
 }
 public void setName(String name) {
 this.name = name;
 }
 public int getAge() {
 return age;
 }
 public void setAge(int age) {
 this.age = age;
 }
}
//测试
public class test02 {
 
 public static void main(String[] args) throws ClassNotFoundException {
 Person person = new Person();
 //方式一、通过包名获取
        Class class1 = Class.forName("com.reflection.Person");
        System.out.println(class1.hashCode());
        //方式二、通过对象获取
        Class class2 = person.getClass();
        System.out.println(class3.hashCode());
        //方式三、通过类获取
        Class class3 = Person.class;
        System.out.println(class3.hashCode());
    }
}
结论：三种方式获取的Class对象为同一个。
3、获取类的运行时结构
public class test03 {
 public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException {
 Class c1 = Class.forName("com.reflection.Person");
 //获得类的名字
 String name = c1.getName();//获得包名加类名
 String simpleName = c1.getSimpleName();//获得类名
 
 //获得类的属性
 Field[] fields = c1.getFields();//获得类的所有公有属性
 Field[] declaredFields = c1.getDeclaredFields();//获得类的所有属性
 Field field = c1.getField(name);//获得类的指定公有属性
 Field declaredField = c1.getDeclaredField(name);//获得类的指定属性（所有类型均可）
  
 //获得类的方法
 Method[] method = c1.getMethods();//获得本类及其父类的所有公有方法
 Method[] declaredMethods = c1.getDeclaredMethods();//获得本类的所有方法
 Method getName = c1.getMethod("getName", null);//获取指定方法(本类及其父类的所有公有方法)
 Method setName = c1.getDeclaredMethod("setName", String.class);//获取指定方法(本类的所有方法)
 
 //获得类的构造器
 Constructor[] constructors = c1.getConstructors();//获取所有公有构造器
 Constructor[] declaredConstructors = c1.getDeclaredConstructors();//获取所有构造器
 Constructor constructor = c1.getConstructor(String.class, int.class);//获取指定公有构造器
 Constructor declaredConstructor = c1.getDeclaredConstructor(String.class, int.class);//获取指定构造器
 
 }
}
4、通过反射构造对象
public class Test04 {
 public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {
  //获得Class对象
  Class c1 = Class.forName("com.reflection.Person");
  //通过反射创建对象
  Person person = (Person)c1.newInstance();//本质上是调用了无参构造器
 
  Constructor constructor = c1.getDeclaredConstructor(String.class,int.class);//获取有参构造器
  Person person2 = (Person) constructor.newInstance("name",18);//调用有参构造器创建对象
 
  //通过反射调用普通方法
  Method setName = c1.getDeclaredMethod("setName", String.class);//获取方法
  setName.invoke(person,"name");//通过invoke调用方法
 
  //通过反射操作属性
  Field name = c1.getDeclaredField("name");//获取name属性
  name.setAccessible(true);//关闭安全检测，关闭后可以访问私有属性（true为关闭，false为打开，默认是false）
  name.set(person,"lalala");//设置属性的值
 
 }
}
5、通过反射获取注解的信息
创建类和注解
@Testclass("db_Student2")//类注解
//创建学生类
class Student2{
 @Testfield(columnname = "name",type = "varchar",length = 20)//属性注解
 String name;
 @Testfield(columnname = "age",type = "int",length = 3)
 int age;
 @Testfield(columnname = "ID",type = "int",length = 10)
 int ID;
 public Student2() {
 }
 public Student2(String name, int age, int ID) {
  this.name = name;
  this.age = age;
  this.ID = ID;
 }
 public String getName() {
  return name;
 }
 public void setName(String name) {
  this.name = name;
 }
 public int getAge() {
  return age;
 }
 public void setAge(int age) {
  this.age = age;
 }
 public int getID() {
  return ID;
 }
 public void setID(int ID) {
  this.ID = ID;
 }
}
//类的注解
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface Testclass{
 String value();
}
//属性的注解
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@interface Testfield{
 String columnname();
 String type();
 int length();
}
测试
public class test05 {
 public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {
  Class c1 = Class.forName("com.zjrcu.reflection.Student2");
 
  //通过反射获得注解
  Annotation[] annotations = c1.getAnnotations();
  for (Annotation annotation : annotations) {
   System.out.println(annotation);
  }
   
  //通过反射获得注解value的值
  Testclass testclass = (Testclass)c1.getAnnotation(Testclass.class);
  String value = testclass.value();
  System.out.println(value);
   
  //获取类中指定注解的value值
  Field f = c1.getDeclaredField("name");
  Testfield testfield = (Testfield) f.getAnnotation(Testfield.class);
  System.out.println(testfield.columnname());
  System.out.println(testfield.length());
  System.out.println(testfield.type());
 
 
 }
}

equals和==的区别
在JVM中，内存分为堆内存跟栈内存。他们二者的区别是：当我们创建一个对象（new Object）时，就会调用对象的构造函数来开辟空间，将对象数据存储到堆内存中，与此同时在栈内存中生成对应的引用，当我们在后续代码中调用的时候用的都是栈内存中的引用。还需注意的一点，基本数据类型是存储在栈内存中。
初步认识equals与==的区别：
==是判断两个变量或实例是不是指向同一个内存空间，equals是判断两个变量或实例所指向的内存空间的值是不是相同 
==是指对内存地址进行比较，equals()是对字符串的内容进行比较
==指引用是否相同，equals()指的是值是否相同

String,StringBuffer区别
String 字符串常量
StringBuffer 字符串变量（线程安全）
StringBuilder 字符串变量（非线程安全）
String类型和StringBuffer类型的主要性能区别其实在于String是不可变的对象,因此在每次对String类型进行改变的时候其实都等同于生成了一个新的String对象，然后将指针指向新的String对象，之前的实例对象仍然存在，如果没有被再次引用，则会被垃圾回收。所以经常改变内容的字符串最好不要用String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM的GC就会开始工作，那速度是一定会相当慢的。
StringBuffer对象则代表一个字符序列可变的字符串，当一个StringBuffer被创建以后，通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列。一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。每次结果都会对StringBuffer对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用StringBuffer，特别是字符串对象经常改变的情况下。	
StringBuffer类中的方法都添加了synchronized关键字，也就是给这个方法添加了一个锁，用来保证线程安全。
在某些特别情况下，String对象的字符串拼接其实是被JVM解释成了StringBuffer对象的拼接，所以这些时候String对象的速度并不会比StringBuffer对象慢，而特别是以下的字符串对象生成中，String效率是远要比StringBuffer快的：
String S1 = “This is only a” + “ simple” + “ test”;
StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);
你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个
String S1 = “This is only a” + “ simple” + “test”; 其实就是：
String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：
String S2 = “This is only a”;
String S3 = “ simple”;
String S4 = “ test”;
String S1 = S2 +S3 + S4;
这时候JVM会规规矩矩的按照原来的方式去做
在大部分情况下StringBuffer> String
StringBuffer上的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。

foreach循环
foreach语句是for语句的特殊简化版本，但是foreach语句并不能完全取代for语句，然而，任何的foreach语句都可以改写为for语句版本。
foreach的语句格式：
for(元素类型t 元素变量x : 遍历对象obj){
引用了x的java语句;
}
foreach简化数组和集合的遍历
foreach语句的局限性:如果要引用数组或者集合的索引，则foreach语句无法做到，foreach仅仅老老实实地遍历数组或者集合一遍。
foreach语句是for语句特殊情况下的增强版本，简化了编程，提高了代码的可读性和安全性（不用怕数组越界）。相对老的for语句来说是个很好的补充。提倡能用foreach的地方就不要再用for了。在用到数组索引的情况下，foreach显得力不从心，这个时候是用for语句的时候了。foreach一般结合泛型使用

java异常
在Java语言中，将程序执行中发生的不正常情况称为“异常”。(开发过程中的语法错误和逻辑错误不是异常)
异常事件可分为两类：
Error:Java虚拟机无法解决的严重问题。如:JVM系统内部错误、资源耗尽等严重情况。比如:StackOverflowError和OOM。一般不编写针对性 的代码进行处理。
Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如:空指针访问 试图读取不存在的文件 网络连接中断 数组角标越界
运行时异常和编译时异常
运行时异常
是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。
对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。
编译时异常
是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。
对于这类异常，如果程序不处理，可能会带来意想不到的结果。

Error和Exception
1.Error
代码示例一：java.lang.OutOfMemoryError（堆溢出）
public class ErrorTest {
 public static void main(String[] args) {
 //堆溢出:java.lang.OutOfMemoryError
 Long[] arr = new Long[1024*1024*1024];
 }
}
代码示例二：java.lang.StackOverflowError（栈溢出）
public class ErrorTest {
 public static void main(String[] args) {
 
 //栈溢出：java.lang.StackOverflowError
 main(args);
 }
}
2.Exception（运行时异常和编译时异常）
运行时异常
/* ******************以下是运行时异常****************** */
//ArithmeticException
@Test
public void test1(){
int num1 = 3;
int num2 = 0;
int num3 = 3 / 0;
}
 
//InputMismatchException
@Test
public void test2(){
Scanner scanner = new Scanner(System.in);
int i = scanner.nextInt();
System.out.println(i);
scanner.close();
}
 
//NumberFormatException
@Test
public void test3(){
String str = "abcd";
int num = Integer.parseInt(str);
}
 
//ClassCastException
@Test
public void test4(){
Object obj = new Boolean(true);
String str = (String)obj;
}
 
//IndexOutOfBoundsException
@Test
public void test5(){
ArrayIndexOutOfBoundsException
Byte[] bytes = new Byte[3];
System.out.println(bytes[4]);
}
 
//NullPointerException
@Test
public void test6(){
int[] arr = null;
System.out.println(arr[1]);
}
编译时异常
/* ******************以下是编译时异常****************** */
 @Test
 public void test7(){
 File file = new File("a.txt");
 //java.io.FileNotFoundException
 FileInputStream fis = new FileInputStream(file);
 //java.io.IOException
 int date = fis.read();
 while (date != -1){
  System.out.println((char)date);
  date = fis.read();
 }
 
 fis.close();
 }
对于编译时异常，我们需要异常处理

异常处理：抓抛模型
抓抛解释
过程一：“抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象， 并将此对象抛出；一旦抛出对象以后，其后的代码就不再执行。
关于异常对象的产生：
①系统自动生成的异常对象
②手动的生成一个异常对象，并抛出（throw）
过程二：“抓”：可以理解为异常的处理方式：① try-catch-finally ② throws
try-catch-finally的使用
try{
//可能出现异常的代码
 
}catch(异常类型1 变量名1){
//处理异常的方式1
}catch(异常类型2 变量名2){
//处理异常的方式2
}catch(异常类型3 变量名3){
//处理异常的方式3
}
…
finally{
//一定会执行的代码
}
finally是可选的。
使用try将可能会出现异常的代码段包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配
一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的
try-catch结构（在没有写finally的情况）。继续执行其后的代码
catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。
catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错
常用的异常对象处理的方式： ① String getMessage() ② printStackTrace()
在try结构中声明的变量，再出了try结构以后，就不能再被调用
try-catch-finally结构可以嵌套
finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。
像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。
@Test
public void test1(){
 String str = "abcd";
 int num = 1314;
 try {
 num = Integer.parseInt(str);
 
 System.out.println("进入try代码块!");
 }catch (NumberFormatException e){
 System.out.println("出现数值转换异常了！");
 System.out.println(e.getMessage());
 e.printStackTrace();
 System.out.println("该catch语句块将要执行完了！");
 } catch (NullPointerException e){
 System.out.println("出现空指针异常！");
 } catch (Exception e){
 System.out.println("出现异常了");
 }finally {
 System.out.println("执行finally语句了！");
 }
 System.out.println(num);
}
@Test
public void test2(){
 File file = new File("a.txt");
 FileInputStream fis = null;
 try {
  fis = new FileInputStream(file);
  int date = fis.read();
  while(date != -1){
   System.out.println((char)date);
   date = fis.read();
  }
 
 
 } catch (FileNotFoundException e) {
  e.printStackTrace();
 }catch (IOException e){
  e.printStackTrace();
 }finally {
  System.out.println("执行finally语句了！");
  try {
   fis.close();
  } catch (IOException e) {
   e.printStackTrace();
  }
 }
}
总结：
使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。
开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对于编译时异常，我们说一定要考虑异常的处理。

throws + 异常类型的使用
"throws + 异常类型"写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！
try-catch-finally:真正的将异常给处理掉了。
throws的方式只是将异常抛给了方法的调用者。 并没有真正将异常处理掉。
子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（子类重写的方法也可以不抛出异常）
public class SuperClass {
 public void method() throws IOException {
 
 }
}
 
class SubClass extends SuperClass{
 //报错，子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型
// public void method() throws Exception{
//
// }
 
 public void method() throws FileNotFoundException{
 
 }
}
开发中如何选择使用try-catch-finally 还是使用throws？ 如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果
子类重写的方法中有异常，必须使用try-catch-finally方式处理。执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws
的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。
public class ErrorThrows {
 public static void method1() throws IOException {
  File file = new File("a.txt");
  FileInputStream fileInputStream = new FileInputStream(file);
   
  int data = fileInputStream.read();
  while(data != -1){
   System.out.println((char)data);
   data = fileInputStream.read();
  }
  fileInputStream.close();
 }
  
 public static void method2() throws IOException {
  method1();
 }
  
 public static void method3() throws IOException {
  method1();
 }
 
 public static void main(String[] args) {
  try {
   method3();
  } catch (IOException e) {
   e.printStackTrace();
  }
 }
}

手动抛出一个异常类对象(throw关键字使用)
public class ReturnException {
 static void method1(){
  try{
   System.out.println("进入方法1");
   throw new RuntimeException("手动抛出异常");
  }catch (Exception e){
   e.printStackTrace();
   System.out.println(e.getMessage());
  } finally {
   System.out.println("执行finally语句了！");
  }
 }
 
 public static void main(String[] args) {
  method1();
 }
}

自定义异常类
自定义异常类，有如下三步骤：
继承于现有的异常结构：RuntimeException 、Exception
提供全局常量：serialVersionUID
提供重载的构造器
自定义异常类：
public class MyExceptionClass extends Exception{
 
 static final long serialVersionUID = -5641210210148784L;
 
 public MyExceptionClass() {
 }
 
 public MyExceptionClass(String message) {
  super(message);
 }
}
手动抛出上述自定义的异常类对象：
public class MyExceptionTest {
 
 static void method1() throws MyExceptionClass {
  Scanner scanner = new Scanner(System.in);
 
  System.out.println("请输入大于0的数据：");
  double next = scanner.nextDouble();
  if(next >0){
   System.out.println("您输入的数据为："+next);
  }else {
   throw new MyExceptionClass("您输入的数据不满足要求！");
  }
 }
 
 public static void main(String[] args) {
  try {
   method1();
  } catch (MyExceptionClass myExceptionClass) {
   myExceptionClass.printStackTrace();
  }
 }
}